# E2EE-Chat 产品需求文档 (PRD)

> **版本：** 0.3
> **日期：** 2024年12月28日

## 1. 简介

### 1.1. 目的

本文档旨在详细描述 E2EE-Chat 聊天平台的功能、特性和用户体验，为项目的理解、维护提供参考，并作为对现有成果的总结和正式记录。  本项目最初的目的是个人出于对端到端加密技术的兴趣和一些技术上的尝试，并带有对现有加密聊天软件（如 Telegram）的借鉴。项目代码已开源在 GitHub 上，旨在为其他开发者提供学习和参考。

### 1.2. 背景

E2EE-Chat 是一个端到端加密的即时通讯平台，旨在提供用户安全私密的聊天体验。所有的消息都在用户的设备上进行加密和解密，确保只有通信双方可以访问消息内容。

### 1.3. 目标用户

本项目主要作为个人学习和技术演示用途。通过在 GitHub 上开源，也希望能够帮助到对端到端加密技术感兴趣的其他开发者。

## 2. 总体目标

* 提供一个用户友好的端到端加密聊天平台（主要作为技术演示）。
* 确保用户消息的私密性和安全性。
* 提供基本的即时通讯功能。

## 3. 功能需求

### 3.1. 用户管理

#### 3.1.1. 用户注册

* **功能描述：** 允许新用户创建账户。
* **用户流程：**
  1. 用户填写包含用户名、展示名、密码和确认密码的注册表单。
  2. 前端在用户输入失焦时对表单进行验证，并异步请求后端验证用户名是否已被占用。
  3. 用户提交表单后，后端生成盐，使用 Argon2id 算法对密码进行散列处理。
  4. 后端调用存储过程，验证用户名不存在后，将用户信息（包括散列后的密码）存入数据库。
  5. 注册成功后，用户将能够登录。
* **数据约束：**
  * 用户名：唯一标识。
  * 用户ID：UUID。

#### 3.1.2. 用户登录

* **功能描述：** 允许已注册用户登录系统。
* **用户流程：**
  1. 用户填写包含用户名和密码的登录表单。
  2. 前端对表单进行基本验证。
  3. 用户提交表单后，后端根据用户名从数据库获取对应的盐。
  4. 后端使用相同的 Argon2id 算法和获取到的盐对用户输入的密码进行散列。
  5. 后端调用存储过程，比对散列后的密码是否与数据库中存储的密码一致。
  6. 同时，前端生成一个 32 字节的安全随机数作为用户主密钥一同提交给后端。
  7. 如果密码验证通过，则建立用户会话，并将用户重定向到保险库根路径。
  8. 如果密码验证失败，则重定向回登录页面，并通过 JSP 显示错误消息。

#### 3.1.3. 用户退出登录

* **功能描述：** 允许用户安全退出当前会话。
* **用户流程：**
  1. 用户点击“退出登录”按钮。
  2. 前端发起请求到后端，后端销毁当前用户的 Session。
  3. 后端将用户重定向到登录页面。

### 3.2. 保险库管理

#### 3.2.1. 保险库根

* **功能描述：** 作为用户访问加密密钥的入口点。
* **用户流程：**
  1. 用户登录后被重定向到保险库根路径。
  2. 后端验证用户登录状态，如果未登录，则重定向回登录页面。
  3. 后端检查用户保险库是否已配置。
    * 如果未配置，则重定向到创建保险库页面。
    * 如果已配置，则检查 `sessionStorage` 是否保存了解密后的私钥。
      * 如果存在，则直接跳转至会话列表页。
      * 如果不存在，则跳转至解密保险库页面。

#### 3.2.2. 创建保险库

* **功能描述：** 允许用户创建用于加密和存储私钥的保险库。
* **用户流程：**
  1. 用户被引导至创建保险库页面。
  2. 用户输入两次一致的 4 位 PIN 码。
  3. 前端从服务器或数据库下载用户的保险库对象（如果存在）。
  4. 前端使用用户输入的 PIN 码和用户主密钥，并加盐，通过 HKDF 派生出保险库密钥。
  5. 前端生成一对 P-256 密钥对（公钥和私钥）。
  6. 前端使用 AES-256-GCM 算法，使用派生出的保险库密钥加密生成的私钥，并生成初始化向量 (IV)。
  7. 前端将公钥、加密后的私钥、盐和 IV 作为表单提交给后端。
  8. 前端将解密后的私钥进行 Base64 编码后保存到 `sessionStorage` 中。
  9. 后端接收到数据后，将其存储到数据库。
  10. 创建成功后，用户被重定向回会话列表页。如果创建失败，则返回创建页，并通过 JSP 显示错误消息。

#### 3.2.3. 解密保险库

* **功能描述：** 允许用户使用 PIN 码解密其保险库，以访问私钥。
* **用户流程：**
  1. 用户被引导至解密保险库页面。
  2. 用户输入 4 位 PIN 码。
  3. 前端下载用户的保险库对象。
  4. 前端使用用户输入的 PIN 码和用户主密钥，并加盐，通过 HKDF 派生出保险库密钥。
  5. 前端使用派生出的保险库密钥和存储的 IV，通过 AES-256-GCM 算法解密存储的私钥。
  6. 如果解密成功（GCM 会验证完整性），前端将解密后的私钥进行 Base64 编码后保存到 `sessionStorage` 中。
  7. 用户被重定向到会话列表页。

### 3.3. 会话管理

#### 3.3.1. 会话列表

* **功能描述：** 展示用户的所有聊天会话。
* **用户流程：**
  1. 用户访问会话列表页面。
  2. 前端每三秒轮询后端接口，获取最新的会话列表数据。
  3. 后端生成一个包含多行 HTML 对象的片段，其中每行代表一个会话，包含对方显示名称、最后上线时间、最后消息时间。
  4. 前端接收到 HTML 片段后，将其渲染到对应的容器中。
  5. 页面包含一个“退出登录”按钮。
  6. 用户可以点击列表中的某个会话跳转到对应的聊天页面，链接由后端 JSP 在渲染时生成。
  7. 用户可以通过输入用户名并提交，打开与现有用户的聊天或发起与新用户的聊天。
  8. 如果输入的用户名不存在，后端重定向回会话列表页，并通过 JSP 显示错误消息。

#### 3.3.2. 聊天

* **功能描述：** 允许用户与其他人进行端到端加密的实时聊天。
* **用户流程：**
  1. 用户点击会话列表中的聊天链接或通过输入用户名发起新的聊天。
  2. 打开聊天页面时，后端 JSP 将对方的公钥（Base64 编码）嵌入到 JavaScript 常量中。
  3. 前端从 `sessionStorage` 中获取用户的私钥（Base64 编码）。
  4. 前端使用 WebCrypto API，通过 ECDH 算法和 P-256 曲线，利用用户的私钥和对方的公钥，派生出一个用于 AES-GCM 加密的会话密钥，密钥长度为 256 位。
  5. 前端每三秒轮询后端接口，获取新的聊天消息，后端返回 JSON 对象。
  6. 接收到新消息时，前端使用协商好的会话密钥、消息对象中的 IV 和密文进行解密。
  7. 用户发送消息时，前端生成一个随机的 IV，使用协商好的会话密钥加密消息内容。
  8. 前端支持基本的 Markdown 格式（bold, italic, underline, strikethrough, monospace），通过正则表达式匹配并渲染。

## 4. 非功能性需求

### 4.1. 安全性

* **端到端加密：**  所有消息内容在发送者设备加密，在接收者设备解密，服务器无法访问明文消息。
* **密码安全：** 使用 Argon2id 进行密码散列，增加密码破解难度。
* **密钥管理：** 使用 PIN 码和主密钥派生加密密钥，保护用户私钥。
* **会话安全：**  依赖于后端 Session 管理机制。
* **跨站脚本攻击 (XSS) 防护：**
  * **用户展示名：**  使用 JSTL (JavaServer Pages Standard Tag Library) 对用户可读的展示名进行转义，防止恶意用户在展示名中注入 HTML 或 JavaScript 代码，从而避免 XSS 攻击。
  * **消息内容：**  在前端解析和渲染聊天消息时，首先将消息内容解析为包含文本和格式信息的对象列表。然后，使用专门的 JavaScript 函数来安全地渲染格式，并将内容插入到 DOM 中，避免直接将未经处理的字符串插入，从而防止消息内容中的 XSS 攻击。
* **数据库安全：**
  * **存储过程：**  所有数据库操作（包括用户注册、登录验证、消息存储等）都通过预定义的存储过程进行。这不仅可以减少数据库交互的往返时间，提升性能，还可以提高安全性。即使服务器端的代码泄露，攻击者也无法直接执行任意 SQL 查询，只能调用预先定义好的存储过程。
  * **用户隔离：**  数据库连接使用一个专门创建的“程序操作员”用户。该用户仅具备执行（EXECUTE）存储过程的权限，而没有任何创建、修改、删除数据库对象（如表、过程、索引）的权限。这限制了潜在攻击者利用泄露的数据库连接信息进行更深入的破坏。
  * **防止 SQL 注入：**  所有与数据库交互的参数都经过严格的验证和参数化处理，以防止 SQL 注入攻击。

### 4.2. 性能

* **实时性：** 通过三秒轮询实现消息的准实时更新。
* **资源占用：**  需要考虑轮询对服务器资源的消耗。

### 4.3. 可用性

* **用户界面：** 使用 Tailwind CSS 进行美化，提供基本的用户友好界面。
* **错误处理：**  在请求过程中发生错误时，会使用一个 SnackBar 风格的消息条展示错误信息，该消息条会在 5 秒后自动消失。在页面初次渲染时，JSP 会注入 JavaScript 代码来立即显示错误消息（如果存在）。

## 5. 技术栈

### 5.1. 后端
* **Java:**  用于构建服务器端逻辑和 API。

### 5.2. 前端
* **HTML:**  用于构建用户界面的结构。
* **CSS (Tailwind CSS):**  用于快速美化用户界面。
* **JavaScript:**  用于处理前端交互、加密解密逻辑和数据渲染。

### 5.3. 服务器
* **Tomcat:**  作为 Java Web 应用的容器来部署和运行 E2EE-Chat。

### 5.4. 数据库
* **PostgreSQL:**  用于持久化存储用户信息、聊天记录等数据。

### 5.5. Maven 依赖

* **jakarta.servlet:jakarta.servlet-api:** 提供 Servlet API，用于处理 HTTP 请求和响应。
* **org.apache.tomcat:tomcat-jsp-api:** 提供 JSP API，用于在 Java Web 应用中生成动态网页。
* **org.postgresql:postgresql:**  PostgreSQL JDBC 驱动，用于连接和操作 PostgreSQL 数据库。
* **com.zaxxer:HikariCP:**  高性能的 JDBC 连接池，用于管理数据库连接，提高性能和资源利用率。
* **org.bouncycastle:bcprov-jdk18on:**  Bouncy Castle 提供的加密库，提供了各种加密算法的实现，例如 Argon2id、AES、P-256 等。
* **com.google.code.gson:gson:**  Google 提供的 JSON 处理库，用于在 Java 对象和 JSON 数据之间进行序列化和反序列化。
* **jakarta.servlet.jsp.jstl:jakarta.servlet.jsp.jstl-api:**  JSTL (JavaServer Pages Standard Tag Library) API，提供了一组用于在 JSP 页面中进行常用操作的标签，例如迭代、条件判断、格式化等。
* **org.glassfish.web:jakarta.servlet.jsp.jstl:**  JSTL 的实现库。